{
  
    
        "post0": {
            "title": "Bits of Numpy",
            "content": "Installing Numpy . # use_conda = False #set to `True` if you want to install numpy using conda else it will be installed using pip # if use_conda: # !conda install numpy # else: # !pip install numpy . import numpy as np np.__version__ . &#39;1.19.2&#39; . What is Numpy . NumPy is the fundamental package for scientific computing in Python. It is a Python library that provides a multidimensional array object, various derived objects (such as masked arrays and matrices), and an assortment of routines for fast operations on arrays, including mathematical, logical, shape manipulation, sorting, selecting, I/O, discrete Fourier transforms, basic linear algebra, basic statistical operations, random simulation and much more. numpy.org . Why Numpy . Python is a higher level language than C, which means it abstracts the details of the computer from you - memory management, pointers, etc, and allows you to write programs in a way which is closer to how humans think. . It is true that C code usually runs 10 to 100 times faster than Python code if you measure only the execution time. However if you also include the development time Python often beats C. For many projects the development time is far more critical than the run time performance. Longer development time converts directly into extra costs, fewer features and slower time to market.Source . So, to get the advantage of both worlds, i.e, faster execution time and development time we can make us of Numpy. . I will tell you how exactly we can make use of Numpy by introducing the following Numpy Strategies :- . UFuncs (Universal Functions) . | Aggregations . | Broadcasting . | Slicing, masking and fancy indexing . | Let&#39;s look at each of these with some simple examples . 1. UFuncs (Univarsal Functions) . ufuncs are the sepcial type of functions defined in Numpy that are operated element-wise on Arrays . I will create a Python List L and a numpy array A with some elements in it. . L = list(range(10_000)) #create list of Integers from 0 to 999 A = np.array(L) #create python list to a numpy array L[0:10], A[0:10] #print 1st 10 elements of the list/array . ([0, 1, 2, 3, 4, 5, 6, 7, 8, 9], array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])) . And i will add some number to every element using List comprehensions for L and ufuncs for A . L = [(l+10) for l in L] #add 10 to each element A = A + 10 #add 10 to each element L[0:10], A[0:10] #print 1st 10 elements of the list/array . ([10, 11, 12, 13, 14, 15, 16, 17, 18, 19], array([10, 11, 12, 13, 14, 15, 16, 17, 18, 19])) . compare which works faster using line magic comand -&gt; %timeit (This line magic command will run the line for specific number of times and gives us the average time it took to run that particular line of code) . %timeit -n 1000 [(l+10) for l in L] %timeit -n 1000 A + 10 . 448 µs ± 18.3 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each) 6.09 µs ± 365 ns per loop (mean ± std. dev. of 7 runs, 1000 loops each) . print(f&quot;Speed increment is almost {464/5.5 :.2f} times&quot;) . Speed increment is almost 84.36 times . There are many ufuncs available, some of them are listed below :- . Arithmetic operators :- + - * / // % .... | Bitwise operators :- &amp; | ~ ^ &gt;&gt; &lt;&lt; .... | Comparision operators :- &lt; &gt; &gt;= &lt;= == != .... | Trignometric operators :- np.sin np.cos np.tan .... | Exponential operators :- np.exp np.log np.log10 .... | . Take a look at official documentation for more ufuncs . 2. Aggregations . Aggregations are the functions that summarizes the values in an array . I will create a Python Lists of list L and a numpy 2d-array A with some elements in it. . L = [[1,11], [2,22], [3,33], [4,44]] #create lists of list with 2 elements in each list A = np.array(L, dtype=np.int) #convert L into a 2d-array of shape 4 x 2 L, A, A.shape . ([[1, 11], [2, 22], [3, 33], [4, 44]], array([[ 1, 11], [ 2, 22], [ 3, 33], [ 4, 44]]), (4, 2)) . Now, let&#39;s find the minimum value in the given array by sepcifying axis i.e along which dimention we want our function to be applied. . A.min(axis = 0) #Gives us the minimum value in each column . array([ 1, 11]) . A.min(axis = 1) #Gives us the minimum value in each row . array([1, 2, 3, 4]) . Now, let;s find the summation of all the values in an array and also along each axis seperately. . A.sum(axis=0) #Gives us the summation in each column . array([ 10, 110]) . A.sum(axis=1) #Gives us the summation in each row . array([12, 24, 36, 48]) . A.sum() #Gives us the summation of all elements if we don&#39;t specify any axis . 120 . Similarly we can use any aggregation functions we want to apply on an array, some of them are given below :- . Functions : Description . np.mean() : Compute the arithmetic mean along the specified axis. | np.std() : Compute the standard deviation along the specified axis. | np.var() : Compute the variance along the specified axis. | np.sum() : Sum of array elements over a given axis. | np.prod() : Return the product of array elements over a given axis. | np.cumsum() : Return the cumulative sum of the elements along a given axis. | np.cumprod() : Return the cumulative product of elements along a given axis. | np.min(), np.max() : Return the minimum / maximum of an array or minimum along an axis. | np.argmin(), np.argmax() : Returns the indices of the minimum / maximum values along an axis | np.all() : Test whether all array elements along a given axis evaluate to True. | np.any() : Test whether any array element along a given axis evaluates to True. source | . 3. Broadcasting . fast.ai . Broadcasting is a set of rules by which ufuncs operate on arrays of different sizes and/or different dimensions . For instance, it&#39;s obvious there is no way to add a 3×3 matrix with a 4×5 matrix, but what if we want to add one scalar (which can be represented as a 1×1 array) with a matrix? Or a vector of size 3 with a 3×4 matrix? In both cases, we can find a way to make sense of this operation. . Broadcasting gives specific rules to codify when shapes are compatible when trying to do an elementwise operation, and how the array of the smaller shape is expanded to match the array of the bigger shape. It&#39;s essential to master those rules if you want to be able to write code that executes quickly. . Broadcasting with a scalar . Broadcasting with a scalar is the easiest type of broadcasting. When we have a array a and a scalar, we just imagine a array of the same shape as a filled with that scalar and perform the operation: . a = np.array([1, 2, 4, 8, 12]) a &gt; 3 . array([False, False, True, True, True]) . How are we able to do this comparison? 3 is being broadcast to have the same dimensions as a. Note that this is done without creating a array full of zeros in memory (that would be very inefficient). . This is very useful if you want to normalize your dataset by subtracting the mean (a scalar) from the entire data set (a matrix) and dividing by the standard deviation (another scalar): . m = np.array([[1., 2, 3], [4,5,6], [7,8,9]]) (m - 5) / 2.73 . array([[-1.46520147, -1.0989011 , -0.73260073], [-0.36630037, 0. , 0.36630037], [ 0.73260073, 1.0989011 , 1.46520147]]) . What if have different means for each row of the matrix? in that case you will need to broadcast a vector to a matrix. . Broadcasting a vector to a matrix . We can broadcast a vector to a matrix as follows: . c = np.array([10.,20,30]) m = np.array([[1., 2, 3], [4,5,6], [7,8,9]]) m.shape,c.shape . ((3, 3), (3,)) . m + c . array([[11., 22., 33.], [14., 25., 36.], [17., 28., 39.]]) . Here the elements of c are expanded to make three rows that match, making the operation possible. Again, Numpy doesn&#39;t actually create three copies of c in memory. . t = np.expand_dims(c, axis=1) t.nbytes #nbytes: This attribute gives the total bytes consumed by the elements of the NumPy array. . 24 . If we want to broadcast in the other dimension, we have to change the shape of our vector to make it a 3×1 matrix. This is done with the unsqueeze method in Numpy: . c = np.array([10.,20,30]) m = np.array([[1., 2, 3], [4,5,6], [7,8,9]]) c = np.expand_dims(c, axis=1) m.shape,c.shape . ((3, 3), (3, 1)) . This time, c is expanded on the column side: . c+m . array([[11., 12., 13.], [24., 25., 26.], [37., 38., 39.]]) . Like before, only three scalars are stored in memory: . t = np.expand_dims(c, axis=1) t.nbytes . 24 . Adding or removing extra dimentions in numpy using None . c.shape, c[None,:].shape,c[:,None].shape, c.squeeze(1).shape . ((3, 1), (1, 3, 1), (3, 1, 1), (3,)) . You can always omit trailing colons, and ... means all preceding dimensions: . c[None].shape,c[...,None].shape . ((1, 3, 1), (3, 1, 1)) . Rules of Broadcasting . When operating on two Arrays, Numpy compares their shapes elementwise. It starts with the trailing dimensions and works its way backward, adding 1 when it meets empty dimensions. Two dimensions are compatible when one of the following is true: . They are equal. | One of them is 1, in which case that dimension is broadcast to make it the same as the other. | . Arrays do not need to have the same number of dimensions. For example, if you have a 256×256×3 array of RGB values, and you want to scale each color in the image by a different value, you can multiply the image by a one-dimensional array with three values. Lining up the sizes of the trailing axes of these arrays according to the broadcast rules, shows that they are compatible: . Image (3d Array): 256 x 256 x 3 Scale (1d Array): (1) (1) 3 Result (3d Array): 256 x 256 x 3 . As an exercise, try to determine what dimensions you will get as an output when you multiply below 2 vectors (v1 * v2) : . v1 = [0,1,2] with shape 3 x 1 v2 = [0,1,2] with shape 1 x 3 . i.e, v1 = np.arange(3).reshape(3,1), v2 = np.arange(3) . v1 . array([[0], [1], [2]]) . v2 . array([0, 1, 2]) . v1 * v2 . array([[0, 0, 0], [0, 1, 2], [0, 2, 4]]) . (v1 * v2).shape . (3, 3) . The reason behind the output shape of [3 x 3] is :- shape of v1 = [3 x 1] shape of v2 = [3] when you try to mutiply arrays of above shape, step 1 :- shape of v2 will become [1 x 3] to match the number of axis of v1 step 2 :- final shapes of v1 and v2 will be equal to [3 x 3], beacuse both axis wil be broadcasted to the higher dimensions to make it the same as the other . Here is slightly complicated exercise, try to determine what dimensions to add (and where) when you need to normalize a batch of images of size 64 x 3 x 256 x 256 (no. of imgs x no. of channels x height x witdh) with vectors of three elements (one for the mean and one for the standard deviation). . 4. Slicing, masking and fancy indexing . indexing in Python lists accepts Integers/slices . L = list(range(10)) L . [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] . L[2] #integer index . 2 . L[1:3] #slice for multiple elements . [1, 2] . indexing in Numpy arrays works similar . A = np.array(L) A[2], A[1:3] . (2, array([1, 2])) . But numpy offers other fast and convenient indexing as well . Masking :- Indexing with Bolean masks . L = [2,4,8,10,12,14,16] A = np.array(L) mask = np.array([False, True, False, True, False, True, False]) mask . array([False, True, False, True, False, True, False]) . A[mask] . array([ 4, 10, 14]) . Masks are often constructed using comparision operators and booelan logic. . mask = (A &gt; 2) &amp; (A &lt; 14) # &quot;&amp;&quot; Bitwise and operator A[mask] . array([ 4, 8, 10, 12]) . Fancy indexing :- Passing a list/array of indicies . A = np.random.randint(10,20, size=(7)) #generate random intergers of size 7 idx = [1, 4, 6] #access 1st, 4th and 6th index A, A[idx] . (array([15, 18, 10, 10, 13, 13, 12]), array([18, 13, 12])) . multiple dimension indexing . m = np.arange(6).reshape(2,3) m . array([[0, 1, 2], [3, 4, 5]]) . m[abs(m - 3) &lt; 2] . array([2, 3, 4]) . All of these operations can be combined and composed in nearly limitless ways ! . Computing Nearest Neighbors using Numpy . Here comes the most exiting part as an example to work with. we will implement Nearest Neighbors Algorithm using Numpy and then we wil gonna compare it with the scikit-learn Implementation . Naive approachrequires 3 nested loops for finding Nearest Neighbors with 2-dimensional data . In general, for points given by Cartesian coordinates in { displaystyle n}n-dimensional Euclidean space, the distance is . $ d left( p,q right) = sqrt { sum _{i=1}^{n} left( q_{i}-p_{i} right)^2 } $ . X = np.random.random((1000,3)) X.shape . (1000, 3) . diff = X.reshape(1000,1,3) - X diff.shape . (1000, 1000, 3) . D = (diff ** 2).sum(2) D.shape . (1000, 1000) . i = np.arange(1000) D[i,i] = np.inf . i = np.argmin(D,1) i[:10] . array([ 43, 50, 530, 717, 910, 352, 978, 799, 16, 333]) . Installing Scikit-learn . # use_conda = False #set to `True` if you want to install numpy using conda else it will be installed using pip # if use_conda: # !conda install scikit-learn # else: # !pip install scikit-learn . from sklearn.neighbors import NearestNeighbors D, i = NearestNeighbors().fit(X).kneighbors(X,2) i[0:10,1] . array([ 43, 50, 530, 717, 910, 352, 978, 799, 16, 333]) . Summary . Writing Python is fast, loops can be slow . | Numpy pushes loops into its compiled layer . Fast Development time of Python | Fast execution time of compiled code | . | . Strategies:- . ufuncs for element-wise operations | Aggregations for array summarizations | Broadcasting for combining arrays | Slicing, masking and indexing for selecting and operating on subsets of arrays | This is my first blog, so i&#39;m happy to hear your comments and advice. Happy Learning . References . This blog post is a notebook version of great talk given by jake vanderplas in pycon-2015. Talk is old, but content is gold. Many thanks to him. | numpy.org | Fastbook NN Foundations | Why Python is slow | Many thanks to ProfessorJeremy Howard for inspiring me to learn Deep learning and to write posts and help others along the way. | .",
            "url": "https://karthik-d-k.github.io/fastblog/2021/05/31/Bits_of_Numpy.html",
            "relUrl": "/2021/05/31/Bits_of_Numpy.html",
            "date": " • May 31, 2021"
        }
        
    
  
    
        ,"post1": {
            "title": "Fastpages Notebook Blog Post",
            "content": "About . This notebook is a demonstration of some of capabilities of fastpages with notebooks. . With fastpages you can save your jupyter notebooks into the _notebooks folder at the root of your repository, and they will be automatically be converted to Jekyll compliant blog posts! . Front Matter . The first cell in your Jupyter Notebook or markdown blog post contains front matter. Front matter is metadata that can turn on/off options in your Notebook. It is formatted like this: . # &quot;My Title&quot; &gt; &quot;Awesome summary&quot; - toc:true- branch: master - badges: true - comments: true - author: Hamel Husain &amp; Jeremy Howard - categories: [fastpages, jupyter] . Setting toc: true will automatically generate a table of contents | Setting badges: true will automatically include GitHub and Google Colab links to your notebook. | Setting comments: true will enable commenting on your blog post, powered by utterances. | . The title and description need to be enclosed in double quotes only if they include special characters such as a colon. More details and options for front matter can be viewed on the front matter section of the README. . Markdown Shortcuts . A #hide comment at the top of any code cell will hide both the input and output of that cell in your blog post. . A #hide_input comment at the top of any code cell will only hide the input of that cell. . The comment #hide_input was used to hide the code that produced this. . put a #collapse-hide flag at the top of any cell if you want to hide that cell by default, but give the reader the option to show it: . import pandas as pd import altair as alt . . put a #collapse-show flag at the top of any cell if you want to show that cell by default, but give the reader the option to hide it: . cars = &#39;https://vega.github.io/vega-datasets/data/cars.json&#39; movies = &#39;https://vega.github.io/vega-datasets/data/movies.json&#39; sp500 = &#39;https://vega.github.io/vega-datasets/data/sp500.csv&#39; stocks = &#39;https://vega.github.io/vega-datasets/data/stocks.csv&#39; flights = &#39;https://vega.github.io/vega-datasets/data/flights-5k.json&#39; . . place a #collapse-output flag at the top of any cell if you want to put the output under a collapsable element that is closed by default, but give the reader the option to open it: . print(&#39;The comment #collapse-output was used to collapse the output of this cell by default but you can expand it.&#39;) . The comment #collapse-output was used to collapse the output of this cell by default but you can expand it. . . Interactive Charts With Altair . Charts made with Altair remain interactive. Example charts taken from this repo, specifically this notebook. . Example 1: DropDown . # use specific hard-wired values as the initial selected values selection = alt.selection_single( name=&#39;Select&#39;, fields=[&#39;Major_Genre&#39;, &#39;MPAA_Rating&#39;], init={&#39;Major_Genre&#39;: &#39;Drama&#39;, &#39;MPAA_Rating&#39;: &#39;R&#39;}, bind={&#39;Major_Genre&#39;: alt.binding_select(options=genres), &#39;MPAA_Rating&#39;: alt.binding_radio(options=mpaa)} ) # scatter plot, modify opacity based on selection alt.Chart(df).mark_circle().add_selection( selection ).encode( x=&#39;Rotten_Tomatoes_Rating:Q&#39;, y=&#39;IMDB_Rating:Q&#39;, tooltip=&#39;Title:N&#39;, opacity=alt.condition(selection, alt.value(0.75), alt.value(0.05)) ) . Example 2: Tooltips . alt.Chart(df).mark_circle().add_selection( alt.selection_interval(bind=&#39;scales&#39;, encodings=[&#39;x&#39;]) ).encode( alt.X(&#39;Rotten_Tomatoes_Rating&#39;, type=&#39;quantitative&#39;), alt.Y(&#39;IMDB_Rating&#39;, type=&#39;quantitative&#39;, axis=alt.Axis(minExtent=30)), # y=alt.Y(&#39;IMDB_Rating:Q&#39;, ), # use min extent to stabilize axis title placement tooltip=[&#39;Title:N&#39;, &#39;Release_Date:N&#39;, &#39;IMDB_Rating:Q&#39;, &#39;Rotten_Tomatoes_Rating:Q&#39;] ).properties( width=500, height=400 ) . Example 3: More Tooltips . label = alt.selection_single( encodings=[&#39;x&#39;], # limit selection to x-axis value on=&#39;mouseover&#39;, # select on mouseover events nearest=True, # select data point nearest the cursor empty=&#39;none&#39; # empty selection includes no data points ) # define our base line chart of stock prices base = alt.Chart().mark_line().encode( alt.X(&#39;date:T&#39;), alt.Y(&#39;price:Q&#39;, scale=alt.Scale(type=&#39;log&#39;)), alt.Color(&#39;symbol:N&#39;) ) alt.layer( base, # base line chart # add a rule mark to serve as a guide line alt.Chart().mark_rule(color=&#39;#aaa&#39;).encode( x=&#39;date:T&#39; ).transform_filter(label), # add circle marks for selected time points, hide unselected points base.mark_circle().encode( opacity=alt.condition(label, alt.value(1), alt.value(0)) ).add_selection(label), # add white stroked text to provide a legible background for labels base.mark_text(align=&#39;left&#39;, dx=5, dy=-5, stroke=&#39;white&#39;, strokeWidth=2).encode( text=&#39;price:Q&#39; ).transform_filter(label), # add text labels for stock prices base.mark_text(align=&#39;left&#39;, dx=5, dy=-5).encode( text=&#39;price:Q&#39; ).transform_filter(label), data=stocks ).properties( width=500, height=400 ) . Data Tables . You can display tables per the usual way in your blog: . df[[&#39;Title&#39;, &#39;Worldwide_Gross&#39;, &#39;Production_Budget&#39;, &#39;Distributor&#39;, &#39;MPAA_Rating&#39;, &#39;IMDB_Rating&#39;, &#39;Rotten_Tomatoes_Rating&#39;]].head() . Title Worldwide_Gross Production_Budget Distributor MPAA_Rating IMDB_Rating Rotten_Tomatoes_Rating . 0 The Land Girls | 146083.0 | 8000000.0 | Gramercy | R | 6.1 | NaN | . 1 First Love, Last Rites | 10876.0 | 300000.0 | Strand | R | 6.9 | NaN | . 2 I Married a Strange Person | 203134.0 | 250000.0 | Lionsgate | None | 6.8 | NaN | . 3 Let&#39;s Talk About Sex | 373615.0 | 300000.0 | Fine Line | None | NaN | 13.0 | . 4 Slam | 1087521.0 | 1000000.0 | Trimark | R | 3.4 | 62.0 | . Images . Local Images . You can reference local images and they will be copied and rendered on your blog automatically. You can include these with the following markdown syntax: . ![](my_icons/fastai_logo.png) . . Remote Images . Remote images can be included with the following markdown syntax: . ![](https://image.flaticon.com/icons/svg/36/36686.svg) . . Animated Gifs . Animated Gifs work, too! . ![](https://upload.wikimedia.org/wikipedia/commons/7/71/ChessPawnSpecialMoves.gif) . . Captions . You can include captions with markdown images like this: . ![](https://www.fast.ai/images/fastai_paper/show_batch.png &quot;Credit: https://www.fast.ai/2020/02/13/fastai-A-Layered-API-for-Deep-Learning/&quot;) . . Other Elements . GitHub Flavored Emojis . Typing I give this post two :+1:! will render this: . I give this post two :+1:! . Tweetcards . Typing &gt; twitter: https://twitter.com/jakevdp/status/1204765621767901185?s=20 will render this: Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 . Youtube Videos . Typing &gt; youtube: https://youtu.be/XfoYk_Z5AkI will render this: . Boxes / Callouts . Typing &gt; Warning: There will be no second warning! will render this: . Warning: There will be no second warning! . Typing &gt; Important: Pay attention! It&#39;s important. will render this: . Important: Pay attention! It&#8217;s important. . Typing &gt; Tip: This is my tip. will render this: . Tip: This is my tip. . Typing &gt; Note: Take note of this. will render this: . Note: Take note of this. . Typing &gt; Note: A doc link to [an example website: fast.ai](https://www.fast.ai/) should also work fine. will render in the docs: . Note: A doc link to an example website: fast.ai should also work fine. . Footnotes . You can have footnotes in notebooks, however the syntax is different compared to markdown documents. This guide provides more detail about this syntax, which looks like this: . For example, here is a footnote {% fn 1 %}. And another {% fn 2 %} {{ &#39;This is the footnote.&#39; | fndetail: 1 }} {{ &#39;This is the other footnote. You can even have a [link](www.github.com)!&#39; | fndetail: 2 }} . For example, here is a footnote 1. . And another 2 . 1. This is the footnote.↩ . 2. This is the other footnote. You can even have a link!↩ .",
            "url": "https://karthik-d-k.github.io/fastblog/jupyter/2020/02/20/test.html",
            "relUrl": "/jupyter/2020/02/20/test.html",
            "date": " • Feb 20, 2020"
        }
        
    
  
    
        ,"post2": {
            "title": "An Example Markdown Post",
            "content": "Example Markdown Post . Basic setup . Jekyll requires blog post files to be named according to the following format: . YEAR-MONTH-DAY-filename.md . Where YEAR is a four-digit number, MONTH and DAY are both two-digit numbers, and filename is whatever file name you choose, to remind yourself what this post is about. .md is the file extension for markdown files. . The first line of the file should start with a single hash character, then a space, then your title. This is how you create a “level 1 heading” in markdown. Then you can create level 2, 3, etc headings as you wish but repeating the hash character, such as you see in the line ## File names above. . Basic formatting . You can use italics, bold, code font text, and create links. Here’s a footnote 1. Here’s a horizontal rule: . . Lists . Here’s a list: . item 1 | item 2 | . And a numbered list: . item 1 | item 2 | Boxes and stuff . This is a quotation . . You can include alert boxes …and… . . You can include info boxes Images . . Code . You can format text and code per usual . General preformatted text: . # Do a thing do_thing() . Python code and output: . # Prints &#39;2&#39; print(1+1) . 2 . Formatting text as shell commands: . echo &quot;hello world&quot; ./some_script.sh --option &quot;value&quot; wget https://example.com/cat_photo1.png . Formatting text as YAML: . key: value - another_key: &quot;another value&quot; . Tables . Column 1 Column 2 . A thing | Another thing | . Tweetcards . Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 Footnotes . This is the footnote. &#8617; . |",
            "url": "https://karthik-d-k.github.io/fastblog/markdown/2020/01/14/test-markdown-post.html",
            "relUrl": "/markdown/2020/01/14/test-markdown-post.html",
            "date": " • Jan 14, 2020"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "This website is powered by fastpages 1. . a blogging platform that natively supports Jupyter notebooks in addition to other formats. &#8617; . |",
          "url": "https://karthik-d-k.github.io/fastblog/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://karthik-d-k.github.io/fastblog/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}